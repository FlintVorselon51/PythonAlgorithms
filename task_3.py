"""
Задание 3.

Для этой задачи:
1) придумайте 1-3 решения (желательно хотя бы два)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.


Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""

"""
1 решение
Оформляем хранилище в виде словаря. Три раза проходим по ключам, сравнивая значения ключей, каждый раз удаляя из
словаря ключ, значение которого является максимальным. Таким образом находим три максимальных элемента из списка
значений словаря
Итоговая сложность: O(n)
"""

# Реализуем хранилище с помощью словаря, где ключ - название компании, а значение - годовая прибыль.
data = {
    'A': 1000,
    'B': 200,
    'C': 5000,
    'D': 3000,
    'E': 10000,
    'F': 6000
}

# Список, в котором будут хранится три компании с наибольшей прибылью.
result = [None, None, None]

for i in range(len(result)):
    for key in data.keys():
        if result[i] is None or data[key] > data[result[i]]:
            result[i] = key
    data.pop(result[i])

print(*result)

"""
2 решение
Создаём список, состоящий из трёх последних элементов в отсортированном списке значений.
Ищем ключи, значения которых соответствуют значениям в полученном списке.
Таким образом, получаем три компании с наибольшей прибылью в списке result.
Итоговая сложность: O(n*log(n)) (из-за использования сортировки)
"""

# Хранилище реализуем также.
data = {
    'A': 1000,
    'B': 200,
    'C': 5000,
    'D': 3000,
    'E': 10000,
    'F': 6000
}

result = []
max_values = sorted(data.values())[-3:]

for key in data.keys():
    if data[key] in max_values:
        result.append(key)

print(*result)

"""
3 решение
Для нахождения 3-х элементов с наибольшими значениями из data.values() сначала вставим в список max_values первые три
элемента, далее, если следующий элемент больше минимального из max_values, то вставляем новый и удаляем минимальный.
Преобразуем список значений в список ключей аналогично второму решению.
Итоговая сложность: O(n)
"""

# Хранилище реализуем также.
data = {
    'A': 1000,
    'B': 200,
    'C': 5000,
    'D': 3000,
    'E': 10000,
    'F': 6000
}

result = []
max_values = []
values = list(data.values())

for i in range(len(values)):
    if i < 3:
        max_values.append(values[i])
        continue
    minimum = min(max_values)
    if values[i] > minimum:
        max_values.append(values[i])
        max_values.remove(minimum)

for key in data.keys():
    if data[key] in max_values:
        result.append(key)

print(*result)

"""
Заключение.
Второе решение самое медленное, так как имеет сложность O(n*log(n)).
Первое и третье решения имеют одинаковую сложность O(n), однако третье является более оптимальным, так как
нам не нужно три раза проходить по практически одному и тому же списку.
"""
