"""
Задание 5.*

Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).

Попробуйте решить эту же задачу,
применив алгоритм "Решето эратосфена" (https://younglinux.info/algorithm/sieve)

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма
"""
import timeit
from math import ceil


def simple(i):
    """Без использования «Решета Эратосфена»"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


def sieve(n):
    a = list(range(n+1))
    lst = []
    i = 2
    m = n
    while len(lst) != n:
        if i == m:
            a += list(range(m+1, m*2+1))
            m *= 2
            for j in lst:
                for k in range(j * ceil(i / j), m, j):
                    a[k] = 0
        if a[i] != 0:
            lst.append(a[i])
            for j in range(i, n + 1, i):
                a[j] = 0
        i += 1
    return lst[-1]


number = 1000
print(timeit.timeit('simple(number)', setup='from __main__ import simple, number', number=10))
print(timeit.timeit('sieve(number)', setup='from __main__ import sieve, number', number=10))


"""
Пришлось немного модифицировать классичиский алгоритм решето Эратосфена, потому что он предполагает, что мы
ищем простые числа до какого-либо числа n, а нам нужно найти n-ое простое число. Для этого я сначала ищу все простые
до n, а затем если мы еще не нашли n простых чисел - расширяю решето в два раза, при этом вычеркивая из него все числа,
которые делятся на простые.
Если поставить маленькие числа, то решето работает примерно с такой же скоростью, что и функция без него, но, когда
стоит задача найти 10000-ое простое число, то можно не дождаться, когда функция без решета вернет значение, в то время
как решето делает это за мгновение.
Я нашёл миллионное простое число (15485863) и проверил действительно ли алгоритм работает правильно.
"""
